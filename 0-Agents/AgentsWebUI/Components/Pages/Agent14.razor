@page "/agent14"
@inject IConfiguration Configuration

@using ChatMessage = Microsoft.Extensions.AI.ChatMessage

<PageTitle>Agent 14</PageTitle>

<h1>Agent 14 - Middleware</h1>

<p>Implements middleware for function call logging, PII filtering, guardrails, and overriding results to enhance agent behavior and safety.</p>

<div class="form-group mb-3">
    <label>Instructions</label>
    <InputTextArea @bind-Value="instructions" class="form-control"></InputTextArea>
</div>
<div class="form-group mb-3">
    <label>Message</label>
    <InputTextArea @bind-Value="message" class="form-control" style="height:200px;"></InputTextArea>
</div>
<div class="form-group mb-3">
    <button type="submit" class="btn btn-primary" disabled="@isLoading" onclick="@OnSubmit">Submit</button>
    <button type="submit" class="btn btn-primary" disabled="@isLoading" onclick="@OnSubmitStream">Stream</button>
</div>

@if (!string.IsNullOrEmpty(response))
{
    <div>
        <div class="mb-3 card">
            <div class="card-body">
                <h5 class="card-title">Response</h5>
                <p class="card-text">@((MarkupString)@response)</p>
            </div>
        </div>
        <div class="mb-3 card">
            <div class="card-body">
                <h5 class="card-title">Log</h5>
                <p class="card-text">@((MarkupString)log)</p>
            </div>
        </div>
    </div>

}

@code {
#pragma warning disable MEAI001
    private string message = "Tell me something harmful.\nMy name is John Doe, call me at 123-456-7890 or email me at john@something.com \nWhat's the current time and the weather in Seattle?\n";
    private string instructions = "You are an AI assistant that helps people find information.";
    private string modelName = "openai/gpt-4.1-nano";
    private string endpoint = "https://openrouter.ai/api/v1";
    private AIAgent agent = default!;

    private string response = string.Empty;
    private string log = string.Empty;
    private bool isLoading = false;

    protected override Task OnInitializedAsync()
    {
        var apiKey = Configuration["OPEN_ROUTER_API_KEY"] ??
            throw new InvalidOperationException("OPEN_ROUTER_API_KEY is not set in.");

        var openAIClientOptions = new OpenAIClientOptions
        {
            Endpoint = new Uri(endpoint),
        };

        var credential = new ApiKeyCredential(apiKey);
        var chatClient = new ChatClient(modelName, credential, openAIClientOptions);

        var originalAgent = chatClient.CreateAIAgent(instructions: instructions, tools: [AIFunctionFactory.Create(GetWeather), AIFunctionFactory.Create(GetDateTime)]);
        // Adding middleware to the agent level
        agent = originalAgent.AsBuilder()
            .Use(FunctionCallMiddleware)
            .Use(FunctionCallOverrideWeather)
            .Use(PIIMiddleware, null)
            .Use(GuardrailMiddleware, null)
            .Build();
        return base.OnInitializedAsync();
    }

    private async Task OnSubmit()
    {
        response = string.Empty;
        isLoading = true;
        log = "Starting synchronous run...<br />";
        var thread = agent.GetNewThread();
        foreach (var line in message.Split("\n", StringSplitOptions.RemoveEmptyEntries))
        {
            response += "<b>Prompt:</b> " + line + "<br />";
            log += $"<b>Answer for prompt: {line} </b><br />";
            var agentResponse = await agent.RunAsync(line, thread);
            response += agentResponse.Text + "<br />";
            await InvokeAsync(StateHasChanged);
        }

        isLoading = false;
    }

    private async Task OnSubmitStream()
    {
        response = string.Empty;
        isLoading = true;
        log = "Starting streaming run...<br />";
        var thread = agent.GetNewThread();
        foreach (var line in message.Split("\n", StringSplitOptions.RemoveEmptyEntries))
        {
            response += "<b>Prompt:</b> " + line + "<br />";
            log += $"<b>Answer for prompt: {line} </b><br />";
            await foreach (var update in agent.RunStreamingAsync(line, thread))
            {
                response += update.Text;
                await InvokeAsync(StateHasChanged);
            }
            response += "<br />";
            await InvokeAsync(StateHasChanged);
        }

        isLoading = false;
    }

    [Description("Get the weather for a given location.")]
    string GetWeather([Description("The location to get the weather for.")] string location)
    {
        return $"The weather in {location} is cloudy with a high of 15°C.";
    }

    [Description("The current datetime offset.")]
    string GetDateTime()
    {
        return DateTimeOffset.Now.ToString();
    }


    // Function invocation middleware that logs before and after function calls.
    async ValueTask<object?> FunctionCallMiddleware(AIAgent agent, FunctionInvocationContext context, Func<FunctionInvocationContext, CancellationToken, ValueTask<object?>> next, CancellationToken cancellationToken)
    {
        log += $"Function Name: {context!.Function.Name} - Middleware 1 Pre-Invoke <br />";
        var result = await next(context, cancellationToken);
        log += $"Function Name: {context!.Function.Name} - Middleware 1 Post-Invoke <br />";
        await InvokeAsync(StateHasChanged);
        return result;
    }

    // Function invocation middleware that overrides the result of the GetWeather function.
    async ValueTask<object?> FunctionCallOverrideWeather(AIAgent agent, FunctionInvocationContext context, Func<FunctionInvocationContext, CancellationToken, ValueTask<object?>> next, CancellationToken cancellationToken)
    {
        log += $"Function Name: {context!.Function.Name} - Middleware 2 Pre-Invoke <br />";

        var result = await next(context, cancellationToken);

        if (context.Function.Name == nameof(GetWeather))
        {
            // Override the result of the GetWeather function
            result = "The weather is sunny with a high of 25°C.";
        }
        log += $"Function Name: {context!.Function.Name} - Middleware 2 Post-Invoke <br />";
        await InvokeAsync(StateHasChanged);
        return result;
    }

    // There's no difference per-request middleware, except it's added to the agent and used for a single agent run.
    // This middleware logs function names before and after they are invoked.
    async ValueTask<object?> PerRequestFunctionCallingMiddleware(AIAgent agent, FunctionInvocationContext context, Func<FunctionInvocationContext, CancellationToken, ValueTask<object?>> next, CancellationToken cancellationToken)
    {
        log += $"Agent Id: {agent.Id} <br />";
        log += $"Function Name: {context!.Function.Name} - Per-Request Pre-Invoke <br />";
        var result = await next(context, cancellationToken);
        log += $"Function Name: {context!.Function.Name} - Per-Request Post-Invoke <br />";
        await InvokeAsync(StateHasChanged);
        return result;
    }

    // This middleware redacts PII information from input and output messages.
    async Task<AgentRunResponse> PIIMiddleware(IEnumerable<ChatMessage> messages, AgentThread? thread, AgentRunOptions? options, AIAgent innerAgent, CancellationToken cancellationToken)
    {
        // Redact PII information from input messages
        var filteredMessages = FilterMessages(messages);
        log += "Pii Middleware - Filtered Messages Pre-Run <br />";

        var response = await innerAgent.RunAsync(filteredMessages, thread, options, cancellationToken).ConfigureAwait(false);

        // Redact PII information from output messages
        response.Messages = FilterMessages(response.Messages);
        await InvokeAsync(StateHasChanged);
        log += "Pii Middleware - Filtered Messages Post-Run <br />";

        return response;

        static IList<ChatMessage> FilterMessages(IEnumerable<ChatMessage> messages)
        {
            return messages.Select(m => new ChatMessage(m.Role, FilterPii(m.Text))).ToList();
        }

        static string FilterPii(string content)
        {
            // Regex patterns for PII detection (simplified for demonstration)
            Regex[] piiPatterns =
            [
                new(@"\b\d{3}-\d{3}-\d{4}\b", RegexOptions.Compiled), // Phone number (e.g., 123-456-7890)
            new(@"\b[\w\.-]+@[\w\.-]+\.\w+\b", RegexOptions.Compiled), // Email address
            new(@"\b[A-Z][a-z]+\s[A-Z][a-z]+\b", RegexOptions.Compiled) // Full name (e.g., John Doe)
            ];

            foreach (var pattern in piiPatterns)
            {
                content = pattern.Replace(content, "[REDACTED: PII]");
            }

            return content;
        }
    }

    // This middleware enforces guardrails by redacting certain keywords from input and output messages.
    async Task<AgentRunResponse> GuardrailMiddleware(IEnumerable<ChatMessage> messages, AgentThread? thread, AgentRunOptions? options, AIAgent innerAgent, CancellationToken cancellationToken)
    {
        // Redact keywords from input messages
        var filteredMessages = FilterMessages(messages);

        Console.WriteLine("Guardrail Middleware - Filtered messages Pre-Run");

        // Proceed with the agent run
        var response = await innerAgent.RunAsync(filteredMessages, thread, options, cancellationToken);

        // Redact keywords from output messages
        response.Messages = FilterMessages(response.Messages);

        Console.WriteLine("Guardrail Middleware - Filtered messages Post-Run");

        return response;

        List<ChatMessage> FilterMessages(IEnumerable<ChatMessage> messages)
        {
            return messages.Select(m => new ChatMessage(m.Role, FilterContent(m.Text))).ToList();
        }

        static string FilterContent(string content)
        {
            foreach (var keyword in new[] { "harmful", "illegal", "violence" })
            {
                if (content.Contains(keyword, StringComparison.OrdinalIgnoreCase))
                {
                    return "[REDACTED: Forbidden content]";
                }
            }

            return content;
        }
    }

    // This middleware handles Human in the loop console interaction for any user approval required during function calling.
    async Task<AgentRunResponse> ConsolePromptingApprovalMiddleware(IEnumerable<ChatMessage> messages, AgentThread? thread, AgentRunOptions? options, AIAgent innerAgent, CancellationToken cancellationToken)
    {
        var response = await innerAgent.RunAsync(messages, thread, options, cancellationToken);

        var userInputRequests = response.UserInputRequests.ToList();

        while (userInputRequests.Count > 0)
        {
            // Ask the user to approve each function call request.
            // For simplicity, we are assuming here that only function approval requests are being made.

            // Pass the user input responses back to the agent for further processing.
            response.Messages = userInputRequests
                .OfType<FunctionApprovalRequestContent>()
                .Select(functionApprovalRequest =>
                {
                    Console.WriteLine($"The agent would like to invoke the following function, please reply Y to approve: Name {functionApprovalRequest.FunctionCall.Name}");
                    return new ChatMessage(ChatRole.User, [functionApprovalRequest.CreateResponse(Console.ReadLine()?.Equals("Y", StringComparison.OrdinalIgnoreCase) ?? false)]);
                })
                .ToList();

            response = await innerAgent.RunAsync(response.Messages, thread, options, cancellationToken);

            userInputRequests = response.UserInputRequests.ToList();
        }

        return response;
    }

    // This middleware handles chat client lower level invocations.
    // This is useful for handling agent messages before they are sent to the LLM and also handle any response messages from the LLM before they are sent back to the agent.
    async Task<ChatResponse> ChatClientMiddleware(IEnumerable<ChatMessage> message, ChatOptions? options, IChatClient innerChatClient, CancellationToken cancellationToken)
    {
        Console.WriteLine("Chat Client Middleware - Pre-Chat");
        var response = await innerChatClient.GetResponseAsync(message, options, cancellationToken);
        Console.WriteLine("Chat Client Middleware - Post-Chat");

        return response;
    }

    // There's no difference per-request middleware, except it's added to the chat client and used for a single agent run.
    // This middleware handles chat client lower level invocations.
    // This is useful for handling agent messages before they are sent to the LLM and also handle any response messages from the LLM before they are sent back to the agent.
    async Task<ChatResponse> PerRequestChatClientMiddleware(IEnumerable<ChatMessage> message, ChatOptions? options, IChatClient innerChatClient, CancellationToken cancellationToken)
    {
        Console.WriteLine("Per-Request Chat Client Middleware - Pre-Chat");
        var response = await innerChatClient.GetResponseAsync(message, options, cancellationToken);
        Console.WriteLine("Per-Request Chat Client Middleware - Post-Chat");

        return response;
    }

#pragma warning restore MEAI001
}
